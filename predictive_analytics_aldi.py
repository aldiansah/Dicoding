# -*- coding: utf-8 -*-
"""Predictive Analytics_Aldi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kAzYoFJ9J7Mqsfo08RuOfs8cvvU1fJXi

# Proyek Pertama : Predictive Analytics
## Motorcycle Price Prediction
ALDIANSAH PERMANA
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns
from sklearn.metrics import mean_squared_error
from sklearn.neighbors import KNeighborsRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import AdaBoostRegressor

"""# Data Loading
https://www.kaggle.com/datasets/nehalbirla/vehicle-dataset-from-cardekho dan diubah ke dalam bentuk dataframe
"""

url = 'https://raw.githubusercontent.com/aldiansah/Dicoding/main/BIKE%20DETAILS.csv'
motor = pd.read_csv(url)
motor

"""Output kode diatas memberikan informasi sebagai berikut:
1.   Terdapat 1061 baris dalam dataset
2.   Terdapat 7 Kolom yaitu: name, selling_price, year, seller_type, owner, km_driven, ex_showroom_price

# Explanatory Data Analysis
Melakukan beberapa tahapan sebagai berikut :

1.   Deskripsi Variabel
2.   Menangani missing value dan outliers
3.   Analisis Univariate
4.   Analisis Multivariate

# Deskripsi Variabel
"""

motor.info()

"""Dari output dapat dilihat bahwa:


1.   Ada 3 kolom bertipe object, yaitu name, seller_type, owner
2.   Terdapat 3 kolom dengan tipe data int64, yaitu selling_price, year, km_driven
3.   Terdapat 1 kolom dengan tipe data float yaitu ex_showroom_price
"""

motor.describe()

"""# Menangani missing value
Melakukan pengecekan terlebih dulu apakah didalam dataset terdapat missing value dengan kode berikut :
"""

motor.isnull().sum()

"""Dapat dilihat bahwa kolom ex_showroom_price memiliki 435 missing value, langkah selanjutnya menggunakan salah satu teknik untuk mengatasi missing value yaitu mengganti missing value dengan nilai mean berikut caranya:"""

motor['ex_showroom_price'] = motor['ex_showroom_price'].fillna(motor['ex_showroom_price'].mean())

motor.isnull().sum()

"""Dapat dilihat bahwa missing value pada kolom ex_showroom_price telah tiada

# Menangani Outliers

Outliers adalah sampel yang nilainya sangat jauh dari cakupan umum data utama. Pada kasus ini, outliers akan dideteksi dengan teknik visualisasi data (boxplot). Kemudian, ouliers akan ditangani dengan teknik IQR method
"""

sns.boxplot(x=motor['selling_price'])

sns.boxplot(x=motor['year'])

sns.boxplot(x=motor['km_driven'])

sns.boxplot(x=motor['ex_showroom_price'])

Q1 = motor.quantile(0.25)
Q3 = motor.quantile(0.75)
IQR=Q3-Q1
motor=motor[~((motor<(Q1-1.5*IQR))|(motor>(Q3+1.5*IQR))).any(axis=1)]

motor.shape

"""# EDA - Analisis Univariate
Analisis univariate merupakan proses untuk mengeksplorasi dan menjelaskan setiap variabel dalam kumpulan data secara terpisah.
"""

numerical = ['selling_price', 'year', 'km_driven','ex_showroom_price']
categorical = ['name', 'seller_type', 'owner']

"""Analisis fitur kategorik"""

feature = categorical[0]
count = motor[feature].value_counts()
percent = 100*motor[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

feature = categorical[1]
count = motor[feature].value_counts()
percent = 100*motor[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

feature = categorical[2]
count = motor[feature].value_counts()
percent = 100*motor[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""Dapat disimpulkan bahwa :

1. Analisis dari kolom name, jenis sepeda motor terbanyak yaitu Bajaj Pulsar 150 dengan jumlah sampel sebanyak 39 sampel dan presentase 4.4 %
2. Analisis dari kolom seller_type dapat diketahui bahwa 876 penjual sepeda motor merupakan perorangan dan 4 diantaranya merupakan dealer
3. Analisis dari kolom owner dapat dilihat bahwa sebanyak 87.6 % sepeda motor hanya dimiliki oleh orang pertama, 11.5 % dimiliki sampai dengan orang kedua dan yang terkahir 0.9 % sepeda motor dimiliki sampai dengan orang ketiga.
"""

motor.hist(bins=50, figsize=(20,15))
plt.show()

"""Dari histogram diatas kita bisa melihat bahwa :

Rentang harga jual sepeda motor dari ratusan dollar sampai dengan 130000 Dollar
Jumlah terbanyak sepeda motor yang dijual berada di rentang harga 20000-40000 Dollar

# Analisis Multivariate
Multivariate EDA menunjukkan hubungan antara dua atau lebih variabel pada data.

Analisis fitur kategorik
"""

cat_features = motor.select_dtypes(include='object').columns.to_list()

for col in cat_features:
  sns.catplot(x=col, y="selling_price", kind="bar", dodge=False, height = 4, aspect = 3,  data=motor, palette="Set3")
  plt.title("Rata-rata 'selling_price' Relatif terhadap - {}".format(col))

"""Dapat dilihat di atas rata-rata selling_price relatif terhadap fitur kategorik, kita memperoleh insight sebagai berikut :

1. Kategori dalam fitur name terlalu banyak sehingga fitur name tidak mempengaruhi fitur selling_price
2. Pada fitur seller_type , individua merupakan yang paling tinggi dalam seller_type memiliki harga rendah. Sehingga fitur seller_type memiliki dampak yang kecil terhadap rata-rata harga jual.
3. Pada fitur owner rata-rata harga cenderung mirip. Rentangnya berada antara 35000 hingga 45000. Sehingga, fitur cut memiliki pengaruh atau dampak yang kecil terhadap rata-rata harga jual.

Analisis fitur kategorik
"""

sns.pairplot(motor, diag_kind = 'kde')

"""Bisa kita lihat bahwa :

1. selling_price memiliki korelasi positip terhadap variabel year dan ex_showroom_price
2. variabel km_driven memiliki korelasi negatif terhadap selling_price
"""

plt.figure(figsize=(10, 8))
correlation_matrix = motor.corr().round(2).abs()

# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""Dapat dilihat matriks korelasi diatas, korelasi fitur year dan ex_showroom_price terhadap fitur selling_price berada pada rentang cukup (0.25 - 0.5) dan fitur yang memiliki korelasi paling tinggi terhadap fitur selling_price yaitu year sebesar 0.58

# Data Preparation
Tahap untuk melakukan proses transformasi pada data sehingga menjadi bentuk yang cocok untuk proses pemodelan.

# Encoding Fitur Categorical
Encoding fitur kategorik menggunakan LabelEncoder.
"""

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()

l = LabelEncoder()
for p in categorical:
    motor[p]=l.fit_transform(motor[p])
motor

"""Train-Test Split
Pembagian data latih dan uji adalah 90:10
"""

from sklearn.model_selection import train_test_split

X = motor.drop(["selling_price"],axis =1)
y = motor["selling_price"]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.1, random_state = 123)

#cek jumlah sampel
print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""Standarisasi
Standarisasi menggunakan teknik StandarScaler dari library Scikitlearn,

StandardScaler melakukan proses standarisasi fitur dengan mengurangkan mean (nilai rata-rata) kemudian membaginya dengan standar deviasi untuk menggeser distribusi. StandardScaler menghasilkan distribusi dengan standar deviasi sama dengan 1 dan mean sama dengan 0.
"""

from sklearn.preprocessing import StandardScaler

numerical_features = ['year','km_driven','ex_showroom_price']
scaler = StandardScaler()
scaler.fit(X_train[numerical_features])
X_train[numerical_features] = scaler.transform(X_train.loc[:, numerical_features])
X_train[numerical_features].head()

X_train[numerical_features].describe().round(4)

"""# Model Development
Model development adalah tahapan di mana kita menggunakan algoritma machine learning untuk menjawab problem statement dari tahap business understanding. Pada tahap ini, kita akan mengembangkan model machine learning dengan tiga algoritma. Kemudian, kita akan mengevaluasi performa masing-masing algoritma dan menentukan algoritma mana yang memberikan hasil prediksi terbaik. Ketiga algoritma yang akan kita gunakan, antara lain:

1. K-Nearest Neighbors
2. Random Forest
3. Boosting Algorithm
"""

# Siapkan dataframe untuk analisis model
models = pd.DataFrame(index=['train_mse', 'test_mse'],
                      columns=['KNN', 'RandomForest', 'Boosting'])

"""K-Nearest Neighbor"""

knn = KNeighborsRegressor(n_neighbors=10)
knn.fit(X_train, y_train)

models.loc['train_mse','knn'] = mean_squared_error(y_pred = knn.predict(X_train), y_true=y_train)

"""Random Forest"""

RF = RandomForestRegressor(n_estimators=50, max_depth=16, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)

models.loc['train_mse','RandomForest'] = mean_squared_error(y_pred=RF.predict(X_train), y_true=y_train)

"""Boosting Algorithm"""

boosting = AdaBoostRegressor(learning_rate=0.05, random_state=55)
boosting.fit(X_train, y_train)
models.loc['train_mse','Boosting'] = mean_squared_error(y_pred=boosting.predict(X_train), y_true=y_train)

X_test.loc[:, numerical_features] = scaler.transform(X_test[numerical_features])

"""Evaluasi Model
Evaluasi dilakukan dengan menggunakan matriks Mean Squared Error yaitu menghitung jumlah selisih kuadrat rata-rata nilai sebenarnya dengan nilai prediksi.
"""

# Buat variabel mse yang isinya adalah dataframe nilai mse data train dan test pada masing-masing algoritma
mse = pd.DataFrame(columns=['train', 'test'], index=['KNN','RF','Boosting'])

# Buat dictionary untuk setiap algoritma yang digunakan
model_dict = {'KNN': knn, 'RF': RF, 'Boosting': boosting}

# Hitung Mean Squared Error masing-masing algoritma pada data train dan test
for name, model in model_dict.items():
    mse.loc[name, 'train'] = mean_squared_error(y_true=y_train, y_pred=model.predict(X_train))/1e3
    mse.loc[name, 'test'] = mean_squared_error(y_true=y_test, y_pred=model.predict(X_test))/1e3

# Panggil mse
mse

fig, ax = plt.subplots()
mse.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

# Prediksi dengan 10 data
prediksi = X_test.iloc[:10].copy()
pred_dict = {'y_true':y_test[:10]}
for name, model in model_dict.items():
    pred_dict['prediksi_'+name] = model.predict(prediksi).round(1)

pd.DataFrame(pred_dict)